import numpy as np
import csv
import random
from Voter import Voter
from Item import Item
from TCR import TCR
from copy import copy
from Probability import Probability
from Registry import Registry

import matplotlib.pyplot as plt


class Simulation:

    @staticmethod
    def set_round(voter, item, probability, registry):
        
        prob_object, prob_vote = random.random(), random.random()

        if probability.will_object(probability, voter, prob_object) and not registry.blocked:
            return Simulation.set_objection(voter, item, probability, registry)

        if probability.will_vote(probability, voter, prob_vote):
            return Simulation.set_vote(voter, item, probability, registry)
        
        return voter
        
    def set_vote(voter, item, probability, registry):
    
        if not voter.has_enough_tokens(registry.stake):
            return

        prob_vote_correct = random.random()

        registry.stake_pool += registry.stake
        voter.set_tokens(voter.get_tokens() - registry.stake)

        if probability.will_vote_correct(probability, voter, prob_vote_correct):
            voter.set_vote(item.is_valid())  # set vote to correct vote
        else:
            voter.set_vote(not item.is_valid())  # sets vote to incorrect vote

        return voter
    
    def set_objection(voter, item, probability, registry):

        objection_cost = 2 * registry.stake

        if not voter.has_enough_tokens(objection_cost):
            return

        prob_object_correct = random.random()

        registry.stake_pool += objection_cost
        voter.set_tokens(voter.get_tokens() - objection_cost)
        voter.set_vote(item.is_objection())
        registry.increase_itens()       

        if probability.will_object_correct(probability, voter, prob_object_correct):
            probability.objection_effect(probability, True)
        else:
            probability.objection_effect(probability, False)

        registry.block()

        return voter

    @staticmethod
    def write_csv(tcr_array, item_array, vote_results):
        with open("output.csv", "w", newline='') as csvfile:
            writer = csv.writer(csvfile)

            # Write header row
            header_row = ["TCR Val", "Valid", "Accept"]
            for i in range(registries.num_voters):
                header_row.append("V" + str(i + 1))
            header_row.append("Total")
            writer.writerow(header_row)

            total = 0
            for i in range(registries.num_items):
                row = ["%.2f" % tcr_array[i].get_tcr_value(), str(item_array[i].is_valid()),
                       str(item_array[i].is_accepted())]
                for j in range(registries.num_voters):
                    total += vote_results[i, j].get_tokens()
                    row.append("%.2f" % vote_results[i, j].get_tokens())
                row.append(str(total))
                total = 0
                writer.writerow(row)

            # Write engagement status
            engagement_row = [""] * 3
            for i in range(registries.num_voters):
                if vote_results[0, i].is_engaged():
                    engagement_row.append("Eng")
                else:
                    engagement_row.append("Uneng")
            writer.writerow(engagement_row)

            # Write information status
            information_row = [""] * 3
            for i in range(registries.num_voters):
                if vote_results[0, i].is_informed():
                    information_row.append("Inf")
                else:
                    information_row.append("Uninf")
            writer.writerow(information_row)

    # Generates a graph with averages per round of tokens generated by category
    def generate_voter_plot(self, vote_results, registry):
        arr_informed_engaged = np.zeros(registry.num_items, dtype=float)
        arr_uninformed_engaged = np.zeros(registry.num_items, dtype=float)
        arr_informed_unengaged = np.zeros(registry.num_items, dtype=float)
        arr_uninformed_unengaged = np.zeros(registry.num_items, dtype=float)

        num_informed_engaged = 0
        num_uninformed_engaged = 0
        num_informed_unengaged = 0
        num_uninformed_unengaged = 0

        for i in range(registry.num_voters):
            voter = vote_results[0, i]
            if voter.is_informed() and voter.is_engaged():
                num_informed_engaged += 1
            elif voter.is_informed() and not voter.is_engaged():
                num_informed_unengaged += 1
            elif not voter.is_informed() and voter.is_engaged():
                num_uninformed_engaged += 1
            elif not voter.is_informed() and not voter.is_engaged():
                num_uninformed_unengaged += 1

        for i in range(registry.num_items):
            for j in range(registry.num_voters):
                voter = vote_results[i, j]
                if voter.is_informed() and voter.is_engaged():
                    arr_informed_engaged[i] += voter.get_tokens()
                elif voter.is_informed() and not voter.is_engaged():
                    arr_informed_unengaged[i] += voter.get_tokens()
                elif not voter.is_informed() and voter.is_engaged():
                    arr_uninformed_engaged[i] += voter.get_tokens()
                elif not voter.is_informed() and not voter.is_engaged():
                    arr_uninformed_unengaged[i] += voter.get_tokens()


            arr_informed_engaged[i] /= num_informed_engaged if num_informed_engaged != 0 else 1
            arr_informed_unengaged[i] /= num_informed_unengaged if num_informed_unengaged != 0 else 1
            arr_uninformed_engaged[i] /= num_uninformed_engaged if num_uninformed_engaged != 0 else 1
            arr_uninformed_unengaged[i] /= num_uninformed_unengaged if num_uninformed_unengaged != 0 else 1


        final = arr_informed_engaged[registry.num_items - 1] - 100
        final += arr_informed_unengaged[registry.num_items - 1] - 100
        final +=  arr_uninformed_engaged[registry.num_items - 1] - 100
        final +=  arr_uninformed_unengaged[registry.num_items - 1] - 100

        print("reward: " + str(final))

        plt.plot(arr_informed_engaged, label='informed-engaged')
        plt.plot(arr_informed_unengaged, label='informed-disengaged')
        plt.plot(arr_uninformed_engaged, label='uninformed-engaged')
        plt.plot(arr_uninformed_unengaged, label='uninformed-disengaged')

        print("num_informed_engaged: " + str(num_informed_engaged))
        print("num_informed_unengaged: " + str(num_informed_unengaged))
        print("num_uninformed_engaged: " + str(num_uninformed_engaged))
        print("num_uninformed_unengaged: " + str(num_uninformed_unengaged))

        plt.xlabel('Voting Round')
        plt.ylabel('Tokens')
        plt.legend(loc='upper left')
        plt.savefig('images/token_infm' + str(Probability.prob_informed)[2] + 'infl' + str(registry.delta)[2:] + '.png')
        plt.show()

    @staticmethod
    def generate_tcr_plot(tcr_array):
        token_values = []
        for tcr in tcr_array:
            token_values.append(tcr.get_tcr_value())
        plt.plot(token_values, label='TCR Value')
        plt.xlabel('Voting Round')
        plt.ylabel('Value')
        plt.legend(loc='upper left')
        plt.savefig('images/tcr_infm' + str(Probability.prob_informed)[2] + 'infl' + str(registries.delta)[2:] + '.png')
        plt.show()

    '''
    wealth of IE class = ( total # of tokens held by IE voters / total # of tokens ) * TCR value

    average wealth of an IE voter = class wealth / # of individuals 
    '''

    def generate_wealth_plot(self, vote_results, tcr_array, registry):
        wealth_ie = np.zeros(registry.num_items, dtype=float)
        wealth_iu = np.zeros(registry.num_items, dtype=float)
        wealth_ue = np.zeros(registry.num_items, dtype=float)
        wealth_uu = np.zeros(registry.num_items, dtype=float)

        num_informed_engaged = 0
        num_uninformed_engaged = 0
        num_informed_unengaged = 0
        num_uninformed_unengaged = 0

        for i in range(registry.num_voters):
            voter = vote_results[0, i]
            if voter.is_informed() and voter.is_engaged():
                num_informed_engaged += 1
            elif voter.is_informed() and not voter.is_engaged():
                num_informed_unengaged += 1
            elif not voter.is_informed() and voter.is_engaged():
                num_uninformed_engaged += 1
            elif not voter.is_informed() and not voter.is_engaged():
                num_uninformed_unengaged += 1

        for i in range(registry.num_items):
            for j in range(registry.num_voters):
                voter = vote_results[i, j]
                if voter.is_informed() and voter.is_engaged():
                    wealth_ie[i] += voter.get_tokens()
                elif voter.is_informed() and not voter.is_engaged():
                    wealth_iu[i] += voter.get_tokens()
                elif not voter.is_informed() and voter.is_engaged():
                    wealth_ue[i] += voter.get_tokens()
                elif not voter.is_informed() and not voter.is_engaged():
                    wealth_uu[i] += voter.get_tokens()

            wealth_ie[i] = (tcr_array[i].get_tcr_value() / tcr_array[i].get_total_tokens()) * (
                    wealth_ie[i] / num_informed_engaged)
            wealth_iu[i] = (tcr_array[i].get_tcr_value() / tcr_array[i].get_total_tokens()) * (
                    wealth_iu[i] / num_informed_unengaged)
            wealth_ue[i] = (tcr_array[i].get_tcr_value() / tcr_array[i].get_total_tokens()) * (
                    wealth_ue[i] / num_uninformed_engaged)
            wealth_uu[i] = (tcr_array[i].get_tcr_value() / tcr_array[i].get_total_tokens()) * (
                    wealth_uu[i] / num_uninformed_unengaged)

        plt.plot(wealth_ie, label='informed-engaged')
        plt.plot(wealth_iu, label='informed-disengaged')
        plt.plot(wealth_ue, label='uninformed-engaged')
        plt.plot(wealth_uu, label='uninformed-disengaged')
        plt.xlabel('Voting Round')
        plt.ylabel('Average Wealth')
        plt.legend(loc='upper left')
        plt.savefig('images/wealth_infm' + str(Probability.prob_informed)[2] + 'infl' + str(registry.delta)[2:] + '.png')
        plt.show()

    def set_tcr_values(self, tcr_array, item_array):
        for i in range(registries.num_items):
            num_tokens = tcr_array[i].get_total_tokens()
            if i != 0:
                tcr = tcr_array[i - 1]
            else:
                tcr = tcr_array[i]

            tcr_array[i] = copy(tcr)
            tcr_array[i].set_total_tokens(num_tokens)

            item = item_array[i]
            if item.is_valid() and item.is_accepted():
                tcr_array[i].set_tcr_value(1, 0, 0, 0)
            elif item.is_valid() and not item.is_accepted():
                tcr_array[i].set_tcr_value(0, 0, 0, 1)
            elif not item.is_valid() and item.is_accepted():
                tcr_array[i].set_tcr_value(0, 0, 1, 0)
            elif not item.is_valid() and not item.is_accepted():
                tcr_array[i].set_tcr_value(0, 1, 0, 0)

    def main(self, probability, registry, quantity_votes):

        vote_results = np.empty((registry.num_items, registry.num_voters), dtype=type(Voter))
        item_array = np.array([Item() for _ in range(registry.num_items)])
        tcr_array = np.empty(registry.num_items, dtype=type(TCR))

        random.seed(2)

        round_time = registries.code_complexity
        
        i = 0

        while round_time >= 1:
            votes_per_round = quantity_votes * round_time 

            accepted_votes = 0
            rejected_votes = 0
            item = Item()

            quantity_votes_round = np.random.poisson(votes_per_round, 1)[0]

            if (quantity_votes_round > registries.num_voters):
                quantity_votes_round = registries.num_voters 


            if round_time != 1:
                registry.unblock()
            
            for j in range(quantity_votes_round):

                if i == 0: 
                    vote_result = self.set_round(Voter(registry.default_tokens, probability.prob_engaged,
                                                                probability.prob_informed), item, probability, registry)

                else:

                    v = copy(vote_results[i - 1, j])
                    v.set_vote(None)
                    vote_result = self.set_round(v, item, probability, registry)

                vote_results = np.resize(vote_results, (registry.num_items, registry.num_voters))
                vote_results[i, j] = vote_result

                if vote_results[i, j].get_vote()  is True:
                    accepted_votes += 1
                elif vote_results[i, j].get_vote() is False:
                    rejected_votes += 1

            item_array = np.resize(item_array, registry.num_items)
            tcr_array = np.resize(tcr_array, registry.num_items)

            if accepted_votes >= rejected_votes:
                # if num of accepted votes is greater than the majority (0.5) then set the item to be accepted
                item.set_acceptance(True)
                num_majority = accepted_votes
            else:
                item.set_acceptance(False)
                num_majority = rejected_votes
            item_array[i] = item
    
            

            #prev_tokens = registry.total_tokens
            #registry.total_tokens = (1 + registry.delta) * registry.total_tokens
            tcr_array[i] = TCR(registry.total_tokens)

            for j in range(registry.num_voters):
                voter = vote_results[i, j]
                num_stake_majority_tokens = registry.stake_pool / num_majority if num_majority != 0 else 0
                #num_inflation_tokens = (registry.total_tokens - prev_tokens) / (accepted_votes + rejected_votes)
                if voter.get_vote() is not None:
                    if item_array[i].is_accepted() == voter.get_vote():
                        # if voter voted correctly, give self.stake value back
                        voter.set_tokens(voter.get_tokens() + num_stake_majority_tokens)

                    # every voter gets total tokens * self.delta tokens
                    #voter.set_tokens(voter.get_tokens() + num_inflation_tokens)
                    voter.set_tokens(voter.get_tokens())
            # self.stake = (self.stake * (1 + self.delta))
            registry.stake = (registry.initial_stake / registry.default_tokens) * (registry.total_tokens / registry.num_voters)

            i = registry.num_items - 1
            round_time /= 2

        self.set_tcr_values(tcr_array, item_array)
        self.write_csv(tcr_array, item_array, vote_results)
        self.generate_voter_plot(vote_results, registry)
        #self.generate_tcr_plot(tcr_array)
        #self.generate_wealth_plot(vote_results, tcr_array, registry)


probabilities = Probability(prob_vote_engaged=0.5, prob_vote_disengaged=0.1, prob_vote_correct_informed=0.5, prob_vote_correct_uninformed=0.1,
                            prob_obj_engaged=0.5, prob_obj_disengaged=0.1, prob_obj_correct_informed=0.5, prob_obj_correct_uninformed=0.1,
                            prob_engaged=0.5, prob_informed=0.5)

registries = Registry(num_voters=8,default_tokens=100.0, delta=0.05, stake=5.0, initial_stake=5.0, code_complexity=8)

quantity_votes = registries.num_voters * (probabilities.prob_engaged * probabilities.prob_vote_engaged + (1 - probabilities.prob_engaged) * probabilities.prob_vote_disengaged)

simulation = Simulation()

simulation.main(probabilities, registries, quantity_votes)
